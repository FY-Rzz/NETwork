
git init: 在当前目录中初始化一个新的Git仓库。
git clone: 从远程仓库克隆代码到本地。
git add: 将更改或新文件添加到Git的暂存区，以准备进行下一次提交。
git commit: 将已添加到暂存区的更改提交到本地仓库。
git push: 将本地仓库中的更改推送到远程仓库中。
git pull: 将远程仓库中的更改拉取到本地仓库中。
git branch: 查看、创建、删除或更改分支。
git checkout: 切换到其他分支或检出历史版本。
git merge: 合并不同分支或历史版本。
git status: 显示仓库中文件的状态。
git log: 查看提交历史记录。
git stash: 将当前更改暂时存储起来，以便稍后重新应用。

 C_Cpp.errorSquiggles
--------------------------------------------
目录
前 言
第1章 PostgreSQL系统概述/1
1.1 PostgreSQL简介及发展历程/1
1.2 PostgreSQL的特性/2
1.3 PostgreSQL的应用/3
1.4 PostgreSQL代码结构/3
1.5 安装PostgreSQL/4
1.6 PostgreSQL数据库命令/5
第2章 PostgreSQL的体系结构/7
2.1 系统表/8
2.1.1 主要系统表功能及依赖关系/8
2.1.2 系统视图/14
2.2 数据集簇/15
2.2.1 initdb的使用/17
2.2.2 postgres.bki/17
2.2.3 initdb的执行过程/19
2.2.4 系统数据库/20
2.3 PostgreSQL进程结构/21
2.4 守护进程Postmaster/22
2.4.1 初始化内存上下文/23
2.4.2 配置参数/23
2.4.3 创建监听套接字/28
2.4.4 注册信号处理函数/29
2.4.5 辅助进程启动/31
2.4.6 装载客户端认证文件/32
2.4.7 循环等待客户连接请求/33
2.5 辅助进程/34
2.5.1 SysLogger系统日志进程/34
2.5.2 BgWriter后台写进程/36
2.5.3 WalWriter预写式日志写进程/38
2.5.4 PgArch预写式日志归档进程/40
2.5.5 AutoVacuum系统自动清理进程/41
2.5.6 PgStat统计数据收集进程/44
2.6 服务进程Postgres/47
2.6.1 初始化内存环境/48
2.6.2 配置运行参数和处理客户端传递的GUC参数/48
2.6.3 设置信号处理和信号屏蔽/48
2.6.4 初始化Postgres的运行环境/49
2.6.5 创建内存上下文并设置查询取消跳跃点/50
2.6.6 循环等待处理查询/50
2.6.7 简单查询的执行流程/52
2.7 小结/53
第3章 存储管理/54
3.1 存储管理器的体系结构/54
3.2 外存管理/57
3.2.1 表和元组的组织方式/58
3.2.2 磁盘管理器/60
3.2.3 VFD机制/61
3.2.4 空闲空间映射表/64
3.2.5 可见性映射表/69
3.2.6 大数据存储/69
3.3 内存管理/76
3.3.1 内存上下文概述/77
3.3.2 高速缓存/84
3.3.3 缓冲池管理/94
3.3.4 IPC/102
3.4 表操作与元组操作/106
3.4.1 表操作/106
3.4.2 元组操作/112
3.5 VACUUM机制/115
3.5.1 VACUUM操作/115
3.5.2 Lazy VACUUM/116
3.5.3 Full VACUUM/118
3.6 ResourceOwner资源跟踪/120
3.7 小结/122
第4章 索引/123
4.1 概述/123
4.1.1 索引方式/124
4.1.2 索引类型/125
4.1.3 索引相关系统表/125
4.1.4 索引的操作函数/129
4.2 B-Tree索引/131
4.2.1 B-Tree索引的组织结构/132
4.2.2 B-Tree索引的操作/135
4.3 Hash索引/146
4.3.1 Hash索引的组织结构/147
4.3.2 Hash索引的实现/153
4.4 GiST索引/161
4.4.1 GiST的扩展性/161
4.4.2 GiST索引的组织结构/162
4.4.3 GiST索引的实现/163
4.4.4 GiST索引实例/166
4.5 GIN索引/168
4.5.1 GIN索引的扩展性/168
4.5.2 GIN索引的组织结构/170
4.5.3 GIN索引的操作/172
4.6 TSearch2全文搜索/179
4.6.1 全文索引的创建/180
4.6.2 全文索引的查询/184
4.6.3 查询结果处理/185
4.7 小结/186
第5章 查询编译/187
5.1 概述/187
5.2 查询分析/188
5.2.1 Lex和Yacc简介/189
5.2.2 词法和语法分析/193
5.2.3 语义分析/208
5.3 查询重写/218
5.3.1 规则系统/219
5.3.2 查询重写的处理操作/224
5.4 查询规划/228
5.4.1 总体处理流程/229
5.4.2 预处理/237
5.4.3 生成路径/240
5.4.4 生成可优化的MIN/MAX聚集计划/253
5.4.5 生成普通计划/254
5.4.6 生成完整计划/257
5.4.7 整理计划树/259
5.4.8 实例分析/260
5.5 代价估计/266
5.5.1 代价估算公式/267
5.5.2 选择度/268
5.5.3 单个表的扫描代价/268
5.5.4 两个表的连接代价/268
5.6 PostgreSQL中的遗传算法/268
5.6.1 个体编码方式及种群初始化/269
5.6.2 适应值/270
5.6.3 父体选择策略/270
5.6.4 杂交算子/270
5.6.5 变异算子/275
5.6.6 终止条件/275
5.6.7 基于排列生成路径/276
5.6.8 实例分析/276
5.7 小结/280
第6章 查询执行/282
6.1 查询执行策略/283
6.1.1 可优化语句和数据定义语句/284
6.1.2 四种执行策略/284
6.1.3 策略选择的实现/286
6.1.4 Portal执行的过程/288
6.2 数据定义语句执行/289
6.2.1 数据定义语句执行流程/289
6.2.2 执行实例/290
6.2.3 主要的功能处理器函数/293
6.3 可优化语句执行/293
6.3.1 物理代数与处理模型/294
6.3.2 物理操作符的数据结构/295
6.3.3 执行器的运行/297
6.3.4 执行实例/301
6.4 计划节点/303
6.4.1 控制节点/304
6.4.2 扫描节点/310
6.4.3 物化节点/319
6.4.4 连接节点/328
6.5 其他子功能介绍/334
6.5.1 元组操作/334
6.5.2 表达式计算/337
6.5.3 投影操作/340
6.6 小结/342
第7章 事务处理与并发控制/343
7.1 事务系统简介/343
7.2 事务系统的上层/344
7.2.1 事务块状态/345
7.2.2 事务块操作/346
7.3 事务系统的底层/348
7.3.1 事务状态/348
7.3.2 事务操作函数/350
7.3.3 简单查询事务执行过程实例/352
7.4 事务保存点和子事务/353
7.4.1 保存点实现原理/353
7.4.2 子事务/353
7.5 两阶段提交/354
7.5.1 预提交阶段/354
7.5.2 全局提交阶段/355
7.6 PostgreSQL的并发控制/355
7.7 PostgreSQL中的三种锁/357
7.7.1 SpinLock/357
7.7.2 LWLock/358
7.7.3 RegularLock/360
7.8 锁管理机制/368
7.8.1 表粒度的锁操作/368
7.8.2 页粒度的锁操作/369
7.8.3 元组粒度的锁操作/369
7.8.4 事务粒度的锁操作/369
7.8.5 一般对象的锁操作/369
7.9 死锁处理机制/370
7.9.1 死锁处理相关数据结构/371
7.9.2 死锁处理相关操作/372
7.10 多版本并发控制/373
7.10.1 MVCC相关数据结构/373
7.10.2 MVCC相关操作/375
7.10.3 MVCC与快照/379
7.11 日志管理/380
7.11.1 SLRU缓冲池/381
7.11.2 CLOG日志管理器/386
7.11.3 SUBTRANS日志管理器/390
7.11.4 MULTIXACT日志管理器/392
7.11.5 XLOG日志管理器/394
7.11.6 日志管理器总结/402
7.12 小结/403
第8章 数据库安全/404
8.1 PostgreSQL安全简介/404
8.2 用户标识和认证/405
8.2.1 客户端配置文件/406
8.2.2 认证方法/408
8.2.3 客户端认证/410
8.3 基于角色的权限管理/413
8.3.1 用户和角色/413
8.3.2 角色相关的系统表/415
8.3.3 角色管理/416
8.4 对象访问控制/426
8.4.1 访问控制列表/426
8.4.2 对象权限管理/428
8.4.3 对象权限检查/432
8.5 小结/433
附录A 用Eclipse开发和调试PostgreSQL/434
-------------------------------------------------------------

select empno,ename,sal from emp
select DISTINCT job from emp;
select empno,ename,sal*12,sal/30 from emp;
select empno,ename,sal*12+5000 as yearsal from emp;
select empno,ename,(sal十200)*12十5000 as yearsal from emp;
select * from emp where sal > 1500；

select * from emp where ename like 'S%';
select * from emp where ename like '_M%';
select * from emp where ename like '%M%';
select * from emp where LEN(ename) like '%M%';
select * from emp where ((job='MANAGER'and deptno=10) or ( job='CLERK'and depptno=20) or ((job <>'MANAGER'and job<>'CLERK'）and sal>2000)) and (ename like '%S%' or ename like '%K%')



创建表空间：

create tablespace my_data
   logging
   datafile 'E:\OracleDBFile\oradata\ORCL\my_data.dbf'
   size 10m
   autoextend on
   next 10m maxsize 1024m
   extent management local;

创建临时表空间：
create temporary tablespace my_temp
    tempfile 'E:\OracleDBFile\oradata\ORCL\my_temp.dbf'
    size 10m
    autoextend on
    next 10m maxsize 1024m
    extent management local;

创建用户：
create user xzw identified by 4841452
    default tablespace my_data
    temporary tablespace my_temp;


-----------------------------------------------------------
dbcreate
这是一个用 C + + 编写的用于创建数据库系统的程序。该程序使用 Record Manager (RM)来创建和管理数据库中的文件。它创建了两个系统目录文件 relcat 和 attrcat，它们分别存储关于数据库关系(表)和属性(列)的元数据。Relcat 文件包含 DataRel 类型的记录，这些记录存储关于每个关系的信息，如名称、记录长度、属性计数以及页和记录的数量。Attrcat 文件包含 DataAttr 类型的记录，这些记录存储有关每个属性的信息，例如它的名称、记录中的偏移量、数据类型、长度和索引号。

程序首先为数据库创建一个名称指定为命令行参数的目录，然后将当前工作目录更改为该目录。然后使用 RM 创建并打开 relcat 和 attrcat 文件。它将 relcat 和 attrcat 关系的记录插入到 relcat 文件中，并将 relcat 和 attrcat 关系属性的记录插入到 attrcat 文件中。

最后，程序关闭 relcat 和 attrcat 文件并退出。

-------------------------------------------------------------
pf_manager
这是一个用 C + + 编写的用于数据库系统的 Page File (PF)组件的程序。PF 组件负责从磁盘上的文件中存储和检索数据页。

该程序包括与 PF 组件相关的几个类和函数的定义，包括 PFManager、 PFFileHandle、 PFBuffer 和 PFError。PFManager 类包含用于创建、销毁、打开和关闭 PF 文件的函数，以及用于在文件中分配和释放页的函数。PFFileHandle 类表示一个打开的 PF 文件，包含有关文件头和文件描述符的信息。PFBuffer 类表示内存中的分页缓冲区，用于缓存分页以提高性能。PFError 类包含 PF 组件的错误代码。

PF 组件的一些主要功能包括 createFile，它创建一个具有给定名称和长度的新 PF 文件，以及 depyFile，它从文件系统中删除一个 PF 文件。OpenFile 函数打开一个现有的 PF 文件，并将文件头读入 PFFileHandle 对象。CloseFile 函数关闭打开的 PF 文件，如果文件头被修改，则将其写回磁盘。AllocPage 函数在 PF 文件中分配一个新页面，并返回新页面的页码，而 disposePage 函数则释放 PF 文件中的一个页面，以便可以重用该页面。GetThisPage 和 getNextPage 函数分别检索特定页面或文件中的下一页面，forcPage 函数将缓冲区中的页面写入磁盘。
------------------------------------------------------------------
ix_manager
这是一个用 C + + 编写的用于数据库系统的 Index Manager (IX)组件的程序。IX 组件负责创建、销毁和管理数据库中存储的数据的 B + 树索引。

该程序包括与 IX 组件相关的几个类和函数的定义，包括 IXManager、 IXIndexHandle 和 IXError。IXManager 类包含用于创建、销毁、打开和关闭 IX 索引的函数。IXIndexHandle 类表示一个打开的 IX 索引，包含有关索引头和指向底层文件的指针的信息。IXError 类包含 IX 组件的错误代码。

IX 组件的一些主要功能包括 createIndex，它创建一个具有给定名称、属性类型和长度的新的 B + 树索引，以及销毁索引，它从文件系统中删除一个 IX 索引。OpenIndex 函数打开一个现有的 IX 索引并为其返回一个 IXIndexHandle 对象，而 closeIndex 函数关闭一个打开的 IX 索引。Insert、 Delete 和 ForcePages 函数分别对索引执行插入、删除和刷新操作。PrintTree 函数将索引的 B + 树结构打印到控制台。

------------------------------------------------------------------

create USER xzw IDENTIFIED BY 4841452

一个用例说明应该分为如下几个部分：1. 简要说明；2. 主要活动者； 3. 次要活动者(可以为空) 4. 前置条件； 5.主要事件流；6.备选事件流  7. 后置条件 
解释下面的代码并对其进行用例说明：
RC SM_Manager::OpenDb(const char *dbName)
{
  if(dbName == NULL)
    return SM_BADOPEN;
  if(bDBOpen) {
    return SM_DBOPEN; 
  }

  if (getcwd(cwd, 1024) < 0) {
    cerr << " getcwd error." << endl;
    return SM_NOSUCHDB;
  }

  if (chdir(dbName) < 0) {
    cerr << " chdir error to " << dbName 
         << ". Does the db exist ?\n";
    return SM_NOSUCHDB;
  }

  RC rc;
  if((rc =	rmm.OpenFile("attrcat", attrfh))
     || (rc =	rmm.OpenFile("relcat", relfh))
    ) 
    return(rc);
  
  bDBOpen = true;
  return (0);
}
